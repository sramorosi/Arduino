
float otheracos(float x)
{
  float negate = float(x < 0);
  float ret = -0.0187293;
  x = abs(x);
  ret = x * -0.0187293;
  ret += 0.0742610;
  ret *= x;
  ret -= 0.2121144;
  ret *= x;
  ret += 1.5707288;
  ret *= sqrt(1.0 - x);
  ret = ret - 2.0 * negate * ret;
  return negate * 3.14159265358979 + ret;
} 

//function inverse_arm_kinematics (c=[0,10,0],lenAB=100,lenBC=120) = 
//  ASSUMES THAT c is on the YZ plane (x is ignored)
//  ASSUMES that A is at [0,0,0]
void inverse_arm_kinematics(float cx,float cy) {
  // calculate the angles given pt C ***Inverse Kinematics***
  // Assumes that joint A of the robot arm is at 0,0  
  float temp,c_len, sub_angle1, sub_angle2;
  c_len = sqrt(pow(cx,2)+pow(cy,2));
  sub_angle1 = atan2(cy,cx);
  sub_angle2 = acos((pow(c_len,2)+pow(lenAB,2)-pow(lenBC,2))/(2*c_len*lenAB));
  new_ang_a = sub_angle1 + sub_angle2;
  new_ang_b = acos((pow(lenBC,2)+pow(lenAB,2)-pow(c_len,2))/(2*lenBC*lenAB));
  return;  // no return value
} 

int int_map(int x, int in_min, int in_max, int out_min, int out_max)
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

// RATE LIMITING MAKES THE INITIALIZATION JUMPY!!!  DOES NOT SEEM TO SMOOTH OPERATION
//#define SVO_RATE_LIMIT 5 // Max servo microsecond change in a loop (to smooth operation)
//  rate limit = 50 for serial on, rate limit = 10 for serial off


void servo_map(joint & jt,int fromLow, int fromHigh, int toLow,int toHigh) {
  // Maps joint angle to the servo microsecond value
  jt.servo_ms = map(jt.arm_angle,fromLow,fromHigh,toLow,toHigh);

  int delta_ms;
  jt.servo_ms_prior = jt.servo_ms; // save the prior value

  /*  Rate limiting
  delta_ms = jt.servo_ms_prior - jt.servo_ms;
  //Serial.print(", DELTA,");
  //Serial.print(delta_ms);
  
  if (delta_ms > SVO_RATE_LIMIT) { // greater positive than limit
    jt.servo_ms = jt.servo_ms_prior - SVO_RATE_LIMIT;
  } else if (delta_ms < -SVO_RATE_LIMIT) { // more negative than limit
    jt.servo_ms = jt.servo_ms_prior + SVO_RATE_LIMIT;
  }   
  */
}
